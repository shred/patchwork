@database PatchWork.guide
@author "Richard Körber"
@(c) "1997-2022 Richard Körber - all rights reserved"
@$VER: PatchWork.guide V1.0 (28. 9.2022)
@wordwrap

@Node Main "Table Of Contents"


           ####         #          #     #   #             #
           #   #        #          #     #   #             #
           #   #  ###  ####   ###  # ##  # # #  ###  # ##  #  #
           ####      #  #    #   # ##  # # # # #   # ##  # # #
           #      ####  #    #     #   # # # # #   # #     ##
           #     #   #  #  # #     #   # ## ## #   # #     # #
           #      ####   ##   #### #   # #   #  ###  #     #  #

                                                            V1.0
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

                          @{B}-- TABLE OF CONTENTS --@{UB}


        1.   @{" Introduction        " link Intro}  how it all started
        2.   @{" Features            " link Features}  of the program
        3.   @{" Copyright           " link Copyright}  and source code

        4.   @{" Usage               " link Usage}  important information!
        5.   @{" Patch Utilities     " link PatchUtils}  could fail!
        6.   @{" Output example      " link Output}  how to read a hit
        7.   @{" Philosophy          " link Philosophy}  behind PatchWork

        8    @{" How it works        " link Work}  technical details
        8.1  @{" commodities.library " link commodities}
        8.2  @{" dos.library         " link dos}
        8.3  @{" exec.library        " link exec}
        8.4  @{" gadtools.library    " link gadtools}
        8.5  @{" graphics.library    " link graphics}
        8.6  @{" intuition.library   " link intuition}
        8.7  @{" utility.library     " link utility}

        A.   @{" Known Bugs          " link Bugs}  and their workaround
        B.   @{" History             " link History}  all changes
        C.   @{" Future              " link Future}  my plans
        D.   @{" Credits             " link Credits}  Thank you!

__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

 PatchWork (C) 1997-2022 Richard Körber -- GPLv3 Licensed

@EndNode
@Node Intro "Introduction"

@{B} I N T R O D U C T I O N @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

PatchWork is another system debugging tool like MuForce, Enforcer, Mungwall,
or Poolwatch. It also makes its output to the debug port, so you should use
Sushi to read it, unless you have got a second computer available...

Now, what does PatchWork do?

It all began when I read the exec.library autodocs and started to wonder if
all the warnings and restrictions mentioned in there are really being
observed. There was no such tool available, at least I hope so ;-), so I
sat down and wrote a first test version of PatchWork.

I expected to see no single PatchWork hit, but to my very surprise I was
wrong. There are a lot of programs throwing PatchWork hits, recent programs as
well as some old Commodore commands, and even ROM functions! So there really
seems to be a demand for that tool...

Well, then I constructed a real tool out of PatchWork. I added better outputs
(as known from e.g. MuForce) and checked even more restrictions. The result
is what you have on your harddisk now.

@EndNode
@Node Features "Features"

@{B} F E A T U R E S @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

These are the features of PatchWork:

   · Catches bad function calls from:
           - commodities.library
           - dos.library
           - exec.library
           - gadtools.library
           - graphics.library
           - intuition.library
           - utility.library

   · Reminds you that a minimum OS version is required for special cases.

   · Full debug output, including registers, stack, PC, disassembly and
     SegTracker. As you are used from MuForce!

   · Additionally, the function call will be shown, too!

   · Four different severity levels, and an adjustable threshold.

   · Does not need a MMU, so there is no excuse @{I}not@{UI} to use it!

   · Pesters you with pedantic PatchWork hits... ;-)

   · Assembler code, handcrafted with 37% more love than comparable tools.
     The speed impact on your system is very low, so you can just keep
     PatchWork running in the background.


What PatchWork is @{B}NOT@{UB}:

   · A replacement for MuForce and/or Mungwall. Use them, too!

   · A system protector that magically 'repairs' bad function calls.
     This is not the philosophy behind PatchWork!


@EndNode
@Node Copyright "Copyright"

@{B} C O P Y R I G H T @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B} GPLv3 LICENSED @{UB}
@{B}----------------@{UB}

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see http://www.gnu.org/licenses/


@{B} CONTENTS OF THE PACKAGE @{UB}
@{B}-------------------------@{UB}

The package is only complete with these files:

PatchWork/PatchWork             (Main program)
PatchWork/PatchWork.guide       (This documentation)
PatchWork/LICENSE.txt           (Full GPLv3 license text)
PatchWork.info
FILE_ID.DIZ

This package might also be a part of the mmu.library package by
Thomas Richter.


@{B} SOURCE CODE @{UB}
@{B}-------------@{UB}

PatchWork is free open source software. You can find the latest source code,
an issue tracker and more on the official development web site:

   https://patchwork.shredzone.org

The source code is intentionally not part of the AmiNet package. To
contribute to PatchWork, you can use the official GitHub repository:

   https://github.com/shred/patchwork

@EndNode
@Node Bugs "Bugs"
@Topic "Annex"

@{B} B U G S @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

If you found a bug or have a feature request, please don't hesistate to open
a new issue on the issue tracker at the official development web site:

   https://patchwork.shredzone.org


@{B} KNOWN BUGS @{UB}
@{B}------------@{UB}

  · PatchWork may freeze the system for some unknown reason. I hope this
    bug will be fixed once I implement the asynchronous I/O routines.


@{B} KNOWN MUFORCE/MUNGWALL/PATCHWORK HITS @{UB}
@{B}---------------------------------------@{UB}

  · none known yet...  :-)


@{B} BUGGY SOFTWARE WORKAROUNDS @{UB}
@{B}----------------------------@{UB}

  · If PatchWork crashes during startup, or shows an 8BADC0DE alert,
    you should try the NOPERMIT option. Anyhow this is an indicator for
    a flawed patch management utility, so find out who made it and write
    them a mail. It's not PatchWork's fault.

@EndNode
@Node History "History"
@Topic "Annex"

@{B} H I S T O R Y @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

V1.1    »
        · Use short relocation tables, prohibits loading on Kick 1.x
          [@polluks]
        · New option TASKNAME. If given, only hits by tasks with that
          name are reported. [@tygre-chingu]

V1.0    » (28.09.2022)
        · After 25 years, I guess PatchWork is finally due for a major
          version bump. ;-)
        · Now built on Linux using vasm.
        · Checks AmigaOS V40 calls. Actually, the only check that needed
          to be added was graphics.library/WriteChunkyPixels.
        · DISPC is now the default behavior. Use the new option NODISPC
          to explicitly disable PC disassembly on PatchWork hits.
        · Bugfix: intuition/SetPointer() hit output was incorrect
          [reported by Hagbard Celine].
        · Correct library name is shown even if A6 is not pointing to
          the library base.

V0.17   » (14. 1.2002)
        · Now Open Source and GPLv3 licensed!
        · Bugfix: "RunCommand() strlen(argptr) does not match to argsize"
          complained though the strlen was correct in reality.
          [Thomas Richter]

V0.16   » ( 5. 1.2000)
        · PatchWork turned out to be millennium proof... ;-)
        · "SetPointer() hot spot is outside of the sprite" is severity 0
          now [Olivier Fabre convinced me]

V0.15   » ( 5.11.1999)
        · V0.14 revision was not bumped
        · Using disassembler.library now to disassemble around the PC,
          with the parameters DISPC and DISRANGE [thanks, Thomas Richter]

V0.14   » (24.10.1999)
        · gadtools.library tests implemented
        · Documentation has been reworked

V0.13   » (10. 9.1999)
        · Bugfix: CxBroker nb_Unique of 3 is legal [Jeroen T. Vermeulen]
        · Ambiguous formulation in this guide's SetCxObjPri() chapter
          [Jeroen T. Vermeulen]
        · Added the NOPERMIT option
        · Renamed "Badness" to "Severity"
        · Reassembled it with proper optimizer settings, saving some
          bytes

V0.12   » ( 4. 4.1998)
        · Bugfix: the ShowHit function scratched A5, resulting that all
          subsequent relative accesses to A5 threw enforcer hits. This
          was a really ugly one. [Børge Nøst]
        · Bugfix: Disable() implies Forbid(), this is honoured in all
          exec checkings now. [Thomas Richter]
        · Bugfix: BitMapScale width>1024 was wrong documented here. Anyhow
          PatchWork was accurate. [Dave]
        · DISABLECHECK implemented
        · Permit() similar checking for Enable()

V0.11   » (12. 2.1998)
        · utility.library tests implemented
        · commodities.library tests implemented

V0.10   » ( 7.11.1997)
        · Bugfix: BestModeIDA() said "0 is not allowed" when the tag is
          exactly *non* null. No good... [Børge Nøst]
        · Removed CopyMem() and CopyMemQuick() with 0 bytes hit. It was
          quite annoying and is absolutely clean, anyhow.
        · Added exec ReleaseSemaphore() and ReleaseSemaphoreList(). Don't
          know why I left them out...
        · AllocSpriteDataA() checks the SPRITEA_OldDataFormat tag now,
          all further checkings are ignored then [Allan Purtle]
        · DeleteMsgPort() now does a level 3 hit if port is still public
        · Removed the superfluous and annoying CreateNewProc() suggestion
        · intuition.library tests implemented
        · PatchWork quits now if called a second time

V0.9    » ( 7.10.1997)
        · Bugfix: signed compares for EraseRect() and RectFill()
        · WaitBOVP() temporarily disabled, due to a clean usage in CGX3
        · Added the MinOS option [Eric Sauvageau]
        · Bad patch manager will result in an Alert (untested)

V0.8    » ( 6. 7.1997)
        · AllocMem() and AllocVec() checking against -1 [Dave Jones]

V0.7    » (10. 6.1997)
        · graphics.library tests implemented
        · CopyMem() and CopyMemQuick() with overlapping areas are
          finally Badness 3. Yeah!
        · Automatical BPTR calculation
        · NULL as STRPTR will not cause Enforcer hits any more
        · WORD parameters are displayed correctly now
        · Mistake in the guide file: AttemptLockDosList() returns
          NULL for failure. PatchWork works accurately, though!
          [Christian Wasner]
        · CreateProc() isn't really obsoleted [Kenny], so it will
          be just a suggestion to use CreateNewProc() and got severity
          level 0.

V0.6    » (29. 5.1997)
        · ROMHITS implemented

V0.5    » (29. 5.1997)
        · dos.library tests implemented

V0.4    » (29. 5.1997)
        · Improved output using a new structure, showing library
          name, function parameters, severity level, cause

V0.3    » (28. 5.1997)
        · STACKLINES,SHOWPC,STACKCHECK,AREGCHECK,DREGCHECK added
        · Bugfix: bad Forbid() state recognition, works fine now

V0.2    » (28. 5.1997)
        · CopyMem(), CopyMemQuick() react on size==0
        · Permit() checks tdNestCnt
        · DEADLY implemented

V0.1    » (26. 5.1997)
        · First internal pre-release

@EndNode
@Node Credits "Credits"
@Topic "Annex"

@{B} C R E D I T S @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

I wish to thank all the people who wrote me! :-)

I also want to give credits to:

  @{B} Thomas Richter @{UB}     for MuForce, the disassembler.library and all his
                       kind help and hints.

  @{B} Eric Sauvageau @{UB}     for his great MINOS idea.

  @{B} Dave Jones @{UB}         for his help regarding memory flushing.

  @{B} Frank Wille @{UB}        for PhxAss, the best assembler available!

  @{B} Michael Sinz @{UB}       for Enforcer, SegTracker and his help for all the
                       bugfree Amiga software.

__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

            //
        \\\\ //   -- Amiga - Old Love Never Dies --
         \\X/

@EndNode
@Node Future "Future"
@Topic "Annex"

@{B} F U T U R E @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

The Amiga platform is dead, or so they say. Is there a future?

Yes, there is. Many people are still enjoying their Amiga as a retro
computer, either on a real hardware, a replica, or on an emulator. I
decided to spend more time writing Amiga software again, so hopefully
there will be new PatchWork releases in the future.

This is what I plan in future releases:

  · Add patchwork checks for AmigaOS 3.2

  · Limit the output to a task name using wildcards

  · Using asynchronous output and also output to the shell

  · Fixing known bugs

  · Checking even more functions and also other libraries

If you have more ideas, just open an issue on the development web site at:

   https://patchwork.shredzone.org

@EndNode
@Node Usage "Usage"
@Topic "Usage"

@{B} U S A G E @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B} REQUIREMENTS @{UB}
@{B}--------------@{UB}

  · AmigaOS 2.04 (V37) or higher (V36 won't work!)
  · A terminal connected to the internal serial port, or Sushi
  · SegTracker (not required, but suggested)
  · disassembler.library by Thomas Richter (optionally)

@{B} INSTALLATION @{UB}
@{B}--------------@{UB}

Just copy PatchWork to your CLI path, and this guide file to whereever
you collect good documentations. ;)

You should start PatchWork @{I}after@{UI} SetPatch and @{I}after@{UI} any
SetFunction() manager (like PatchControl).

@{B} START @{UB}
@{B}-------@{UB}

You need to start PatchWork from the shell, as it is no Workbench tool.

PatchWork won't detach itself, so you should use "run <>NIL: PatchWork" if
you want to start it in the startup-sequence.

You can always shut down a running PatchWork by pressing <CTRL>-<C>,
sending a break, or starting another instance of PatchWork.

@{B} SHELL PARAMETERS @{UB}
@{B}------------------@{UB}

@{B}LEVEL/K/N@{UB}       Set the severity threshold. Defaults to 0. More about
                severity levels see below.

@{B}MINOS/K/N@{UB}       You can provide the minimal required OS version of your
                program here. Any PatchWork hit that is fixed starting
                from this OS version will be suppressed. E.g. if your
                program requires at least AmigaOS 39, just provide MINOS=39.

@{B}TINY/S@{UB}          Tiny output. Just show the cause of the hit.

@{B}SMALL/S@{UB}         Small output. Shows the cause of the hit and the PC,
                TCB and Task name.

@{B}STACKLINES/K/N@{UB}  Number of stack lines to be written. Each stack line
                consists of 32 stack bytes. There is no limit here!

@{B}STACKCHECK/S@{UB}    Check all stack entries with SegTracker

@{B}SHOWPC/S@{UB}        Show 32 bytes around the current PC

@{B}AREGCHECK/S@{UB}     Check the contents of the address registers with
                SegTracker.

@{B}DREGCHECK/S@{UB}     Check the contents of the data registers with
                SegTracker.

@{B}ROMHITS/S@{UB}       Usually, all hits caused by the AmigaOS ROM will be
                suppressed. With this option set, they will also be shown.
                Yes, the AmigaOS ROM actually throws PatchWork hits, and a
                lot of them!

@{B}DEADLY/S@{UB}        With this option set, some functions will return a worst
                case value instead of the real return value under certain
                conditions. See patch documentation below.

@{B}DISABLECHECK/S@{UB}  It is only allowed to disable system interrupts for a
                maximum time of 250ms. This option will check if that time
                limit is kept. A 68020 or better is required for this test.
                Even more, this test could cause hardware timeouts, so be very
                careful and do not use this option permanently.
                @{B}If in doubt, do not use this option!@{UB}

@{B}NOPERMIT/S@{UB}      Does not patch the Permit() function. This is useful
                if your system crashes while starting PatchWork (or shows an
                8BADC0DE alert), caused by a poor patch management utility.
                There is no reason to use this option if PatchWork starts up
                without any problems on your machine.

@{B}NODISPC/S@{UB}       The code around the current PC is disassembled if
                Thomas Richter's disassembler.library is present. Use this
                option to disable the disassembler. Note that in previous
                versions there was a DISPC option that worked the other way
                around. If you used DISPC, you can leave it out now, as it
                is the default behavior.

@{B}DISRANGE/K/N@{UB}    Range of bytes to be disassembled before and after the
                PC. Defaults to 32.

@{B}TASKNAME/K@{UB}      Only report hits by tasks with the given name. Note
                that only the output is filtered, but all PatchWork checks
                will still apply, and DEADLY is also still effective for all
                tasks. This is for performance reasons.


@{B} SEVERITY LEVELS @{UB}
@{B}-----------------@{UB}

All hits are divided into four severity levels. The higher the level, the
more likely is a system crash being caused by the problem.

   0    Hits with level 0 won't crash the system. They are legal and
        absolutely harmless. Level 0 hits are just reminders, e.g. that
        a minimal AmigaOS version is required for the function or the way
        it is used. Also see MINOS.

   1    Hits with level 1 won't crash the system as well. Instead they
        warn that an obsoleted function has been invoked, or that the
        invocation parameters are just useless or time-wasting.
        "AllocMem(0)" or "OldOpenLibrary()" would result in level 1 hits.

   2    Hits with level 2 might crash the system, especially with
        multitasking interaction. These are e.g. FindPort()s without
        a prior Forbid(). You must not rely on a result you get from
        a level 2 hit, as the state might have already been changed
        after the function returned.

        With the DEADLY option, some of the level 2 hits will try to
        crash your program by returning worst case values.

   3    Hits with level 3 will make your software unstable, and will
        crash the system sooner or later. They are used against explicit
        rules of the AutoDocs, and will thus have unpredictable results.
        They might also result in memory leaks. In any way, even if they
        seem to work, they are just @{B}wrong@{UB} and must be corrected.

        Two examples: CopyMem() with overlapping memory areas, or
        DeleteMsgPort() without clearing up the message queue before.

@{B}ANY@{UB} hit starting from level 1 is a real bad hit, and should be fixed
if possible, to enhance system stability and future compatibility.

@EndNode
@Node Work "How it works"
@Topic "Usage"

@{B} H O W   I T   W O R K S @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

In a nutshell, PatchWork just patches a set of library functions. If one
of them is called, PatchWork checks the structures and parameters that
are passed in, and validates if they meet the AutoDocs specifications.

If a check should fail, you will be notified through the debug channel,
or through the Sushi output console.

PatchWork is not made to protect your system from crashing. It won't
correct bad structures and parameters. It just reports what it found,
and will then leave you alone with that mess. :-)

In fact, you can even try to crash your program by using the DEADLY option.

Note: We can discuss about anything, but not about something you explicitely
MUST or MUST NOT do according to the AutoDocs. The AutoDocs are law! Even
if it turns out that your code doesn't seem to crash your system, it is
simply wrong to make assumptions or break explicit rules.

@EndNode
@Node PatchUtils "Patch Utilities"
@Topic "Usage"

@{B} P A T C H   U T I L I T I E S @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

The AmigaOS' native patch functionality is quite limited. If multiple
patches are applied to library calls, they must be removed in reverse
order. Otherwise the system might crash.

There are some patch management utilities that try to mitigate the
problem by managing the patches that are applied. With such a patch
manager, patches can be applied and removed in any order. It is highly
recommended to use such an utility, to enhance system stability.

Anyhow there may be problems if some of those utilities are used in
combination with PatchWork. This is because PatchWork is also patching
some very fundamental functions, like AllocMem() and Permit().

If PatchWork is used together with a poorly written patch manager, your
system may become unstable or crash right away when PatchWork is started.
The only way to fix that is to use a different patch manager utility.

Let me explain a little deeper how PatchWork hooks into the system, and
about the problems that might be caused by that.


@{B} FUNCTION TROUBLE @{UB}
@{B}------------------@{UB}

A serious problem is if the replacement SetFunction() routine of the
patch manager uses certain OS functions right after setting the new
function vector. Let me explain why.

For example, our program is supposed to patch the Permit() function.

This is the state before SetFunction() is invoked:

                +----------+                            +--------------------+
  BEFORE        | Permit() |--------------------------->| Permit OS function |
                +----------+                            +--------------------+
                                 +--------------+
                                 | Permit patch |-----> NIL
                                 +--------------+

We can see the Permit() entry pointing to the Permit OS function in ROM, and
our patch which has not been inserted yet.

Usually SetFunction() writes the new function pointer into the library's
function table, and then returns the pointer to the old function that was
found there and that is now about to be patched.

  After         +----------+                            +--------------------+
  SetFunction() | Permit() |-+               Return --->| Permit OS function |
                +----------+ |                          +--------------------+
                             |   +--------------+
                             +-->| Permit patch |-----> NIL
                                 +--------------+

Our patch can now use the old function pointer to jump to the original
Permit OS function:

                +----------+                            +--------------------+
  AFTER         | Permit() |-+                     +--->| Permit OS function |
                +----------+ |                     |    +--------------------+
                             |   +--------------+  |
                             +-->| Permit patch |--+
                                 +--------------+

If Permit() is invoked now, our Permit patch is called first. It does whatever
it is supposed to do, and then delegates to the original Permit function of
the operating system.

There is one weak point though! After SetFunction() has been executed, but
before our patch is pointing back to the original ROM function, the Permit
patch points to NIL. If another task would call Permit() in this very moment,
the system would crash.

This usually cannot happen, as patches are applied while multitasking is
forbidden. But if the patch management utility itself would call Permit(),
the system would crash.

If a PatchWork patch is invoked before it is properly chained to the original
function, it will show an "8BADC0DE" alert. If you get such an alert while
starting PatchWork, it is a sign that your patch manager is faulty. Another
sign for a faulty patch manager is if your Amiga immediately crashes while
starting PatchWork.


@{B} STACK TROUBLE @{UB}
@{B}---------------@{UB}

It is crucial that PatchWork finds the caller's PC on the stack, and nothing
before that. If a patch utility pushes some data onto the stack before
starting the patch functions, PatchWork will show the code of the patch
manager instead of the true invoker.

I haven't found a patch utility with that problem yet. Anyhow, be prepared.


@{B} WORKING ONES @{UB}
@{B}--------------@{UB}

These Utilities are known to work with PatchWork:

  · PatchControl V2.3 or higher (AlienDesign, see MCP packet)
  · SaferPatches V2.04 or higher
  · No patch utility at all... ;-)


@{B} FAILING ONES @{UB}
@{B}--------------@{UB}

These Utilities are known to fail:

  · SaferPatches V2.03 and before
  · MagicMenu V2.25 (use PatchWork's NOPERMIT option)


@{B} INSTALLATION @{UB}
@{B}--------------@{UB}

If you are using a patch manager, make sure it is started first, before
PatchWork is launched. Don't start it afterwards!

If the system crashes while PatchWork is starting, or if the "8BADC0DE"
alert appears, then try to use a newer version of the patch manager utility,
or find a different one.

There is an alternative you can try. If PatchWork is started with the
NOPERMIT parameter, it won't patch the exec/Permit() function. This will
help in some cases, like e.g. MagicMenu V2.25. However it also disables the
Permit() check, so only use this option if necessary.

@EndNode
@Node Output "Output example"
@Topic "Usage"

@{B} O U T P U T   E X A M P L E @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

This is how a PatchWork hit looks like:

exec.library OldOpenLibrary("dos.library")
Severity 1: obsoleted, use OpenLibrary() instead
PC=07E9BCFC TCB=07BF34A0 ("Shell Process")
Data: FFFFFFFF 00000000 00000000 00000000 00000000 00000000 00000000 00000000
Addr: 07EA2A3A 07E9FF46 00000000 00000000 00000000 00000000 078007F8 07BF4510
----> 07EA2A3A - "pwtest"	Hunk 0001, Offset 00008A4A
----> 07E9FF46 - "pwtest"	Hunk 0001, Offset 00005F56
PC-8: 51CEFF22 4E7570FF 23C007EA 251E41FA 6D4E23C8 07EA2522 43FA4250 2C780004
PC *: 4EAEFE68 23C007EA 253A6100 7F886100 089A23C0 07EA266A 6700024C 203C0000
07e9bcdc :  51ce ff22                  dbra d6,$7e9bc00
07e9bce0 :  4e75                       rts
07e9bce2 :  70ff                       moveq.l #-$1,d0
07e9bce4 :  23c0 07ea 251e             move.l d0,$7ea251e
07e9bcea :  41fa 6d4e                  lea.l $7ea2a3a(pc),a0
07e9bcee :  23c8 07ea 2522             move.l a0,$7ea2522
07e9bcf4 :  43fa 4250                  lea.l $7e9ff46(pc),a1
07e9bcf8 :  2c78 0004                  movea.l $4.w,a6
07e9bcfc : *4eae fe68                  jsr -$198(a6)
07e9bd00 :  23c0 07ea 253a             move.l d0,$7ea253a
07e9bd06 :  6100 7f88                  bsr $7ea3c90
07e9bd0a :  6100 089a                  bsr $7e9c5a6
07e9bd0e :  23c0 07ea 266a             move.l d0,$7ea266a
07e9bd14 :  6700 024c                  beq $7e9bf62
07e9bd18 :  203c 0000 2800             move.l #$2800,d0
Stck: 07E9BD00 07BA246C 00000001 00F95C92 00000FA0 4D656761 20536F75 6E644372
Stck: 61636B65 72000000 07BF5E28 00000B48 02090909 05050500 00001111 114E4E4E
----> 07E9BCFC - "pwtest"	Hunk 0001, Offset 00001D0C
----> 07E9BD00 - "pwtest"	Hunk 0001, Offset 00001D10
----> 07BA246C - "pwtest"	Hunk 0000, Offset 0000000C
----> 00F95C92 - "ROM - dos 40.3 (1.4.93)"	Hunk 0000, Offset 000005AE
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

Now for the single lines:

The first line contains what function caused the hit:

@{FG SHINE}
exec.library OldOpenLibrary("dos.library")@{FG FILL}
                            ^^^^^^^^^^^^^--- passed parameters
             ^^^^^^^^^^^^^^----------------- function name
^^^^^^^^^^^^-------------------------------- library name
@{FG TEXT}

The second one describes the hit itself:

@{FG SHINE}
Severity 1: obsoleted, use OpenLibrary() instead@{FG FILL}
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^--- cause
^^^^^^^^^^---------------------------------------- severity level
@{FG TEXT}

(With the TINY option set, no more lines are displayed.)

The third line locates the hit:

@{FG SHINE}
PC=07E9BCFC TCB=07BF34A0 ("Shell Process")@{FG FILL}
                          ^^^^^^^^^^^^^^^--- task name
                ^^^^^^^^-------------------- address of the task structure
   ^^^^^^^^--------------------------------- address of the JSR instruction
                                             that caused the hit.
@{FG TEXT}

(With the SMALL option set, no more lines are displayed.)

After that, the data and address register contents follow:

@{FG SHINE}
Data: FFFFFFFF 00000000 00000000 00000000 00000000 00000000 00000000 00000000
Addr: 07EA2A3A 07E9FF46 00000000 00000000 00000000 00000000 078007F8 07BF4510
@{FG TEXT}

If you enabled DREGCHECK or AREGCHECK, the contents of any register will be
passed to SegTracker (of course SegTracker must be running):

@{FG SHINE}
----> 07EA2A3A - "pwtest"	Hunk 0001, Offset 00008A4A
----> 07E9FF46 - "pwtest"	Hunk 0001, Offset 00005F56
@{FG TEXT}

With SHOWPC enabled, 64 bytes around the PC at hit time will be shown:

@{FG SHINE}
PC-8: 51CEFF22 4E7570FF 23C007EA 251E41FA 6D4E23C8 07EA2522 43FA4250 2C780004
PC *: 4EAEFE68 23C007EA 253A6100 7F886100 089A23C0 07EA266A 6700024C 203C0000
@{FG TEXT}

About 32 bytes of code around the invoking JSR are disassembled now,
unless the NODISPC option was set.

@{FG SHINE}
07e9bcdc :  51ce ff22                  dbra d6,$7e9bc00
07e9bce0 :  4e75                       rts
07e9bce2 :  70ff                       moveq.l #-$1,d0
07e9bce4 :  23c0 07ea 251e             move.l d0,$7ea251e
07e9bcea :  41fa 6d4e                  lea.l $7ea2a3a(pc),a0
07e9bcee :  23c8 07ea 2522             move.l a0,$7ea2522
07e9bcf4 :  43fa 4250                  lea.l $7e9ff46(pc),a1
07e9bcf8 :  2c78 0004                  movea.l $4.w,a6
07e9bcfc : *4eae fe68                  jsr -$198(a6)
07e9bd00 :  23c0 07ea 253a             move.l d0,$7ea253a
07e9bd06 :  6100 7f88                  bsr $7ea3c90
07e9bd0a :  6100 089a                  bsr $7e9c5a6
07e9bd0e :  23c0 07ea 266a             move.l d0,$7ea266a
07e9bd14 :  6700 024c                  beq $7e9bf62
07e9bd18 :  203c 0000 2800             move.l #$2800,d0
@{FG TEXT}

With the DISRANGE option, the number of disassembled bytes can
be changed. The disassembler.library needs to be installed for
this output block.

After that, all stack lines will be shown. You can change the number of stack
lines using the STACKLINES parameter. Defaults to 2 lines.

@{FG SHINE}
Stck: 07E9BD00 07BA246C 00000001 00F95C92 00000FA0 4D656761 20536F75 6E644372
Stck: 61636B65 72000000 07BF5E28 00000B48 02090909 05050500 00001111 114E4E4E
@{FG TEXT}

If SegTracker is running, it will be fed with the PC:

@{FG SHINE}
----> 07E9BCFC - "pwtest"	Hunk 0001, Offset 00001D0C
@{FG TEXT}

And last but not least, if STACKCHECK is enabled, all longwords shown in the
stack lines above are passed to SegTracker:

@{FG SHINE}
----> 07E9BD00 - "pwtest"	Hunk 0001, Offset 00001D10
----> 07BA246C - "pwtest"	Hunk 0000, Offset 0000000C
----> 00F95C92 - "ROM - dos 40.3 (1.4.93)"	Hunk 0000, Offset 000005AE
@{FG TEXT}

@EndNode
@Node Philosophy "Philosophy"
@Topic "Annex"

@{B} P H I L O S O P H Y @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

I am getting a lot of feedback like: "Hey, this function is working fine,
why does PatchWork bark about it?" Okay, let me tell you the philosophy
behind PatchWork, and software documentation in general.

In the early days, when the first home computers like the ZX Spectrum and
C64 were popular, computers were some kind of static. They were constructed
by smart engineers, and then they were never touched again. Even if there
were hardware improvements, the kernel ROM did not change, to ensure
compatibility with existing software.

This was because everyone could buy a book with the commented ROM listing,
and then they knew where to find what function, and exact details of the
kernel functionality. And since only one software could run on these systems
simultaneously, you didn't need to care about sharing resources, and you
never had to deal with 3rd party software updates.

Well, times have changed. The static ROM has been replaced by operating
systems, which are updated frequently (at least they should be). These
systems are able to run a number of programs simultaneously, but since
they run on the same hardware, they have to share their resources.

You have to follow exact rules if you want to write software that can
interact with several versions of the operating system and other software
installed on the software.

First, you always have to use the operating system instead of accessing
the hardware resources yourself. A good example for this is the DraCo,
an Amiga clone by MacroSystem that does not use the Amiga chipset. Still,
well-written Amiga software can run on that system without modifications.

The other, even more crucial thing is documentation. You don't know how
the operating system or the piece of software works exactly. You aren't
ought to know it, and you won't even be able to know since software is
growing more and more complex. So there is only one interface between your
software and the operating system. This is the documentation that explains
how your operating system works.

If you are a tool programmer, you rely that the OS call works exactly as
documented. You want to have a certain result if you pass in the right
mixture of parameters.

If you are a driver or patch programmer, you rely that OS functions were
called in a definite way. You cannot catch all variations and eventualities,
since this would unnecessarily slow down your function.

I want to mention a good example of what happens when people ignore the
documentation. When the Amiga started to become popular, it was delivered
with AmigaOS 1.2, and later with AmigaOS 1.3. Some people wrote programs
like they had been used to write them on their C64: They knew the addresses
of some functions in the ROM, or they knew for example that the
graphics.library was always the 3rd library after exec.library (or was
it the 4th, I don't know exactly). So, to save some microseconds, they
ignored the documentation and used their hacks. And they worked fine!

Then came the day when Commodore released AmigaOS 2.0.

This was really a black day for the Amiga, because a LOT of games and
hacker tools crashed on the new AmigaOS. Commodore was not to be blamed,
they did the right thing. Instead of trying to be compatible to as many
existing programs as possible (which was the philosophy of Microsoft
these days), they did a hard break and were only downward compatible to
their documented features. So all conformously written software still
worked on AmigaOS 2.0, while all the hacks crashed awfully.

Sadly, Commodore WAS blamed for the crashing applications! In all shops,
the new Amiga models were considered as unstable, not compatible and just
awful. I heard a lot of sellers telling their customers this bullsh*t!
They suggested to also buy an AmigaOS 1.3 ROM and a ROM switch, but it
would void the warranty. Most customers decided to better buy a PC with
Windows 3.1, which was said to be more stable.

This rumour of AmigaOS being incompatible and unstable, was told for a
long time. And all this just because some lame programmers ignored the
rules and wrote some bad hacks.

As you see, the documentation is the most important part if you want to
write rock stable and reliable software. And this is why you should use
PatchWork! Certainly, PatchWork is no guarantee that your software will
still run on future AmigaOS releases, but it comes very close to that.

PatchWork knows about the AutoDocs, the MUSTs and MUST-NOTs. And it is
quite pedantic. It will surely annoy you some time with hits that seem to
be harmless at the first sight. But if you fix these hits, you can be sure
that your program might also work with clean system patches, OS updates or
other software.

Anyhow, if you don't get any PatchWork hits, it is no sign for your program
being 100% compatible. It also depends on some other factors. The best rule
of thumb is not to try to outsmart the system, and not to regard undocumented
features as given. If you find some behaviour that is not documented, better
try to find a documented way to reach your goal, instead of just using the
undocumented feature and rely on that it will still work in the future.

@EndNode
@Node commodities "commodities.library"
@Topic "Checks"

@{B} c o m m o d i t i e s . l i b r a r y @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

These commodities.library patches are implemented:

                @{" AttachCxObj " link AttachCxObj}
                @{" CxBroker " link CxBroker}
                @{" CxMsgData " link CxMsgData}
                @{" CxMsgID " link CxMsgID}
                @{" CxMsgType " link CxMsgType}
                @{" DisposeCxMsg " link DisposeCxMsg}
                @{" DivertCxMsg " link DivertCxMsg}
                @{" EnqueueCxObj " link EnqueueCxObj}
                @{" InsertCxObj " link InsertCxObj}
                @{" RouteCxMsg " link RouteCxMsg}
                @{" SetCxObjPri " link SetCxObjPri}

@EndNode
@Node AttachCxObj "commodities.library / AttachCxObj"
@Nav "AttachCxObj"
@Parent commodities

@{B} c o m m o d i t i e s . l i b r a r y @{UB}                      @{B} AttachCxObj @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          V38+ required for headObj==NULL

@{B}SEVERITY@{UB}        Level 0, MinOS 38

@{B}EXPLANATION@{UB}     NULL does only work since V38

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node CxBroker "commodities.library / CxBroker"
@Nav "CxBroker"
@Parent commodities

@{B} c o m m o d i t i e s . l i b r a r y @{UB}                         @{B} CxBroker @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          nb_Name string is too long
                nb_Title string is too long
                nb_Descr string is too long

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     You must keep the maximum string length as defined in
                <libraries/commodities.h>. If you use locale.library for
                the strings, set the maximum length in the .cd as well.

@{B}DEADLY@{UB}          has no effect.

__________________________________________________________________________


@{B}REPORT@{UB}          nb_Name string is NULL
                nb_Title string is NULL
                nb_Descr string is NULL

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     You must provide these strings.

@{B}DEADLY@{UB}          has no effect.

__________________________________________________________________________


@{B}REPORT@{UB}          nb_Unique 1234 is not allowed

@{B}SEVERITY@{UB}        Level 1

@{B}EXPLANATION@{UB}     The provided nb_Unique value is not defined in the
                <libraries/commodities.h>. Do not forget to initialize
                this variable as well!

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node CxMsgData "commodities.library / CxMsgData"
@Nav "CxMsgData"
@Parent commodities

@{B} c o m m o d i t i e s . l i b r a r y @{UB}                        @{B} CxMsgData @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          V38+ required for cxm==NULL

@{B}SEVERITY@{UB}        Level 0, MinOS 38

@{B}EXPLANATION@{UB}     NULL does only work since V38

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node CxMsgID "commodities.library / CxMsgID"
@Nav "CxMsgID"
@Parent commodities

@{B} c o m m o d i t i e s . l i b r a r y @{UB}                          @{B} CxMsgID @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          cxm must not be NULL

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     NULL is not allowed, and will throw MuForce hits.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node CxMsgType "commodities.library / CxMsgType"
@Nav "CxMsgType"
@Parent commodities

@{B} c o m m o d i t i e s . l i b r a r y @{UB}                        @{B} CxMsgType @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          cxm must not be NULL

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     NULL is not allowed, and will throw MuForce hits.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node DisposeCxMsg "commodities.library / DisposeCxMsg"
@Nav "DisposeCxMsg"
@Parent commodities

@{B} c o m m o d i t i e s . l i b r a r y @{UB}                     @{B} DisposeCxMsg @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          cxm must not be NULL

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     NULL is not allowed, and will throw MuForce hits.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node DivertCxMsg "commodities.library / DivertCxMsg"
@Nav "DivertCxMsg"
@Parent commodities

@{B} c o m m o d i t i e s . l i b r a r y @{UB}                      @{B} DivertCxMsg @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          cxm must not be NULL

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     NULL is not allowed, and will throw MuForce hits.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node EnqueueCxObj "commodities.library / EnqueueCxObj"
@Nav "EnqueueCxObj"
@Parent commodities

@{B} c o m m o d i t i e s . l i b r a r y @{UB}                     @{B} EnqueueCxObj @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          V38+ required for headObj==NULL

@{B}SEVERITY@{UB}        Level 0, MinOS 38

@{B}EXPLANATION@{UB}     NULL does only work since V38

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node InsertCxObj "commodities.library / InsertCxObj"
@Nav "InsertCxObj"
@Parent commodities

@{B} c o m m o d i t i e s . l i b r a r y @{UB}                      @{B} InsertCxObj @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          V38+ required for headObj==NULL

@{B}SEVERITY@{UB}        Level 0, MinOS 38

@{B}EXPLANATION@{UB}     NULL does only work since V38

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node RouteCxMsg "commodities.library / RouteCxMsg"
@Nav "RouteCxMsg"
@Parent commodities

@{B} c o m m o d i t i e s . l i b r a r y @{UB}                       @{B} RouteCxMsg @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          cxm must not be NULL

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     NULL is not allowed, and will throw MuForce hits.

@{B}DEADLY@{UB}          has no effect.

__________________________________________________________________________


@{B}REPORT@{UB}          co must not be NULL

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     NULL is not allowed, and will throw MuForce hits.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node SetCxObjPri "commodities.library / SetCxObjPri"
@Nav "SetCxObjPri"
@Parent commodities

@{B} c o m m o d i t i e s . l i b r a r y @{UB}                      @{B} SetCxObjPri @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          Priority is out of range (-128..127)

@{B}SEVERITY@{UB}        Level 1

@{B}EXPLANATION@{UB}     Even though the parameter is LONG, you must keep the
                BYTE range as stated in the AutoDocs.

@{B}DEADLY@{UB}          has no effect.

__________________________________________________________________________


@{B}REPORT@{UB}          V38+ required for a result

@{B}SEVERITY@{UB}        Level 0, MinOS 38

@{B}EXPLANATION@{UB}     The old CxObj priority is only returned since V38.

@{B}DEADLY@{UB}          0xFACEDEAD is returned in any case.

@EndNode
@Node dos "dos.library"
@Topic "Checks"

@{B} d o s . l i b r a r y @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

   These dos.library patches are implemented:

                @{" AttemptLockDosList " link AttemptLockDosList}
                @{" CreateProc " link CreateProc}
                @{" DoPkt " link DoPkt}
                @{" Examine " link Examine}
                @{" ExamineFH " link ExamineFH}
                @{" ExAll " link ExAll}
                @{" ExAllEnd " link ExAllEnd}
                @{" ExNext " link ExNext}
                @{" GetVar " link GetVar}
                @{" Info " link Info}
                @{" MatchEnd " link MatchEnd}
                @{" MatchFirst " link MatchFirst}
                @{" MatchNext " link MatchNext}
                @{" RunCommand " link RunCommand}
                @{" SetVBuf " link SetVBuf}

   @{B}NOTE:@{UB} BPTRs are marked with a 'Bx' prefix and will
automagically be transformed into an APTR for your convenience!

@EndNode
@Node AttemptLockDosList "dos.library / AttemptLockDosList"
@Nav "AttemptLockDosList"
@Parent dos

@{B} d o s . l i b r a r y @{UB}                               @{B} AttemptLockDosList @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          also returns 0x00000001 until V39.24 dos

@{B}SEVERITY@{UB}        Level 0, MinOS 40

@{B}EXPLANATION@{UB}     Due to a bug, this function could also return 1
                for failure. This bug is fixed in dos.library V39.24,
                which was released @{I}after@{UI} AmigaOS V39.106! Thus,
                a check against dos V39 is not sufficient.

                I hope you took this into consideration when using the
                function!

@{B}DEADLY@{UB}          If not successful, DEADLY returns the worst case
                return code, namely 0x00000001. If your program is bad, it
                will think about a successful call even though this call
                failed. Unfortunately, this won't crash your system. :(

@EndNode
@Node CreateProc "dos.library / CreateProc"
@Nav "CreateProc"
@Parent dos

@{B} d o s . l i b r a r y @{UB}                                       @{B} CreateProc @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          pri is out of range (-128..127)

@{B}SEVERITY@{UB}        Level 2

@{B}EXPLANATION@{UB}     Even though pri is LONG, you must keep a BYTE
                range!

@{B}DEADLY@{UB}          has no effect.

__________________________________________________________________________


@{B}REPORT@{UB}          stack size must be a multiple of 4

@{B}SEVERITY@{UB}        Level 2

@{B}EXPLANATION@{UB}     No further comment required, I think...

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node DoPkt "dos.library / DoPkt"
@Nav "DoPkt"
@Parent dos

@{B} d o s . l i b r a r y @{UB}                                            @{B} DoPkt @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          DoPkt() from a task requires V37+

@{B}SEVERITY@{UB}        Level 0, MinOS 37

@{B}EXPLANATION@{UB}     You called DoPkt() from a task. This is only possible
                since AmigaOS V37. Remember that!

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node Examine "dos.library / Examine"
@Nav "Examine"
@Parent dos

@{B} d o s . l i b r a r y @{UB}                                          @{B} Examine @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          FileInfoBlock is not longword aligned

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     Longword alignment is vital for this function. Other-
                wise MuForce and Mungwall hits will occur! Creating this
                structure on stack is not sufficient.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node ExamineFH "dos.library / ExamineFH"
@Nav "ExamineFH"
@Parent dos

@{B} d o s . l i b r a r y @{UB}                                        @{B} ExamineFH @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          FileInfoBlock is not longword aligned

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     Longword alignment is vital for this function. Other-
                wise MuForce and Mungwall hits will occur! Creating this
                structure on stack is not sufficient.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node ExAll "dos.library / ExAll"
@Nav "ExAll"
@Parent dos

@{B} d o s . l i b r a r y @{UB}                                            @{B} ExAll @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          buffer is not word aligned

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     buffer must be at least word aligned. Better do a
                longword alignment if possible!

@{B}DEADLY@{UB}          has no effect.

__________________________________________________________________________


@{B}REPORT@{UB}          buffer should be longword aligned

@{B}SEVERITY@{UB}        Level 1

@{B}EXPLANATION@{UB}     It is even better if you longword align the buffer.
                And it doesn't hurt. So why don't you do it? :-)

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node ExAllEnd "dos.library / ExAllEnd"
@Nav "ExAllEnd"
@Parent dos

@{B} d o s . l i b r a r y @{UB}                                         @{B} ExAllEnd @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          buffer is not word aligned

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     buffer must be at least word aligned. Do a longword
                alignment if ever possible!

@{B}DEADLY@{UB}          has no effect.

__________________________________________________________________________


@{B}REPORT@{UB}          buffer should be longword aligned

@{B}SEVERITY@{UB}        Level 1

@{B}EXPLANATION@{UB}     It is even better if you longword align the buffer.
                And it doesn't hurt. So why don't you do it? :-)

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node ExNext "dos.library / ExNext"
@Nav "ExNext"
@Parent dos

@{B} d o s . l i b r a r y @{UB}                                           @{B} ExNext @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          FileInfoBlock is not longword aligned

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     Longword alignment is vital for this function. Other-
                wise MuForce and Mungwall hits will occur! Creating this
                structure on stack is not sufficient.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node GetVar "dos.library / GetVar"
@Nav "GetVar"
@Parent dos

@{B} d o s . l i b r a r y @{UB}                                           @{B} GetVar @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          this flags will require V37+

@{B}SEVERITY@{UB}        Level 0, MinOS 37

@{B}EXPLANATION@{UB}     GVF_DONT_NULL_TERM in combination with GVF_LOCAL_ONLY
                is only available since AmigaOS V37.

@{B}DEADLY@{UB}          has no effect.

__________________________________________________________________________


@{B}REPORT@{UB}          this flags will require V39+

@{B}SEVERITY@{UB}        Level 0, MinOS 39

@{B}EXPLANATION@{UB}     GVF_DONT_NULL_TERM without GVF_LOCAL_ONLY is only
                available since AmigaOS V39.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node Info "dos.library / Info"
@Nav "Info"
@Parent dos

@{B} d o s . l i b r a r y @{UB}                                             @{B} Info @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          parameterBlock is not longword aligned

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     Longword alignment is vital for this function. Other-
                wise MuForce and Mungwall hits will occur! Creating this
                structure on stack is not sufficient.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node MatchEnd "dos.library / MatchEnd"
@Nav "MatchEnd"
@Parent dos

@{B} d o s . l i b r a r y @{UB}                                         @{B} MatchEnd @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          AnchorPath is not longword aligned

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     Longword alignment is vital for this function. Other-
                wise MuForce and Mungwall hits will occur! Creating this
                structure on stack is not sufficient.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node MatchFirst "dos.library / MatchFirst"
@Nav "MatchFirst"
@Parent dos

@{B} d o s . l i b r a r y @{UB}                                       @{B} MatchFirst @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          AnchorPath is not longword aligned

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     Longword alignment is vital for this function. Other-
                wise MuForce and Mungwall hits will occur! Creating this
                structure on stack is not sufficient.

@{B}DEADLY@{UB}          has no effect.

@{B}REMARK@{UB}          In fact, it is quite funny that even Commodore did it
                wrong on AddDataTypes, Dir and Mount. Use "Patches" from
                Flavio Stanchina (flavio@ies.it) to remove those hits.

@EndNode
@Node MatchNext "dos.library / MatchNext"
@Nav "MatchNext"
@Parent dos

@{B} d o s . l i b r a r y @{UB}                                        @{B} MatchNext @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          AnchorPath is not longword aligned

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     Longword alignment is vital for this function. Other-
                wise MuForce and Mungwall hits will occur! Creating this
                structure on stack is not sufficient.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node RunCommand "dos.library / RunCommand"
@Nav "RunCommand"
@Parent dos

@{B} d o s . l i b r a r y @{UB}                                       @{B} RunCommand @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          argptr does not end with '\\n'

@{B}SEVERITY@{UB}        Level 2, MinOS 38

@{B}EXPLANATION@{UB}     The argument string must end with \\n, so even old parsers
                and old AmigaOS releases can handle it correctly.

@{B}DEADLY@{UB}          has no effect.

__________________________________________________________________________


@{B}REPORT@{UB}          strlen(argptr) does not match to argsize

@{B}SEVERITY@{UB}        Level 1

@{B}EXPLANATION@{UB}     argsize does not match the real argument string length.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node SetVBuf "dos.library / SetVBuf"
@Nav "SetVBuf"
@Parent dos

@{B} d o s . l i b r a r y @{UB}                                          @{B} SetVBuf @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          buff is not longword aligned

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     You must longword align the buffer!

@{B}DEADLY@{UB}          has no effect.

__________________________________________________________________________


@{B}REPORT@{UB}          not implemented until V40+

@{B}SEVERITY@{UB}        Level 0, MinOS 40

@{B}EXPLANATION@{UB}     In fact, this function is not implemented up to AmigaOS
                V39! You can call it, but it will always succeed with
                returncode 0, even though it did nothing!

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node exec "exec.library"
@Topic "Checks"

@{B} e x e c . l i b r a r y @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

   These exec.library patches are implemented:

                @{" AddPort " link AddPort}
                @{" AllocMem " link AllocMem}
                @{" AllocVec " link AllocVec}
                @{" CopyMem " link CopyMem}
                @{" CopyMemQuick " link CopyMemQuick}
                @{" CreateIORequest " link CreateIORequest}
                @{" DeleteMsgPort " link DeleteMsgPort}
                @{" Enable " link Enable}
                @{" FindPort " link FindPort}
                @{" FindSemaphore " link FindSemaphore}
                @{" FindTask " link FindTask}
                @{" FreeSignal " link FreeSignal}
                @{" InitSemaphore " link InitSemaphore}
                @{" OldOpenLibrary " link OldOpenLibrary}
                @{" Permit " link Permit}
                @{" Procure " link Procure}
                @{" ReleaseSemaphore " link ReleaseSemaphore}
                @{" ReleaseSemaphoreList " link ReleaseSemaphoreList}
                @{" SetFunction " link SetFunction}
                @{" Vacate " link Vacate}

@EndNode
@Node AddPort "exec.library / AddPort"
@Nav "AddPort"
@Parent exec

@{B} e x e c . l i b r a r y @{UB}                                        @{B} AddPort @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          port name not initialized

@{B}SEVERITY@{UB}        Level 2

@{B}EXPLANATION@{UB}     With this function, the MsgPort will be made publically
                available. Thus, a valid ln_Name entry must be provided,
                so FindPort() can find your node without trouble.

                If ln_Name is a NULL pointer, FindPort() will cause
                MuForce hits.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node AllocMem "exec.library / AllocMem"
@Nav "AllocMem"
@Parent exec

@{B} e x e c . l i b r a r y @{UB}                                       @{B} AllocMem @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          allocating 0 bytes

@{B}SEVERITY@{UB}        Level 1

@{B}EXPLANATION@{UB}     Allocating 0 bytes is ugly, wastes time and might also
                fail. Avoid this if possible.

@{B}DEADLY@{UB}          has no effect.

__________________________________________________________________________


@{B}REPORT@{UB}          don't use AllocMem(-1) to flush memory

@{B}SEVERITY@{UB}        Level 1

@{B}EXPLANATION@{UB}     To flush the memory, you should either call AvailMem(),
                then add some byte to the result and allocate this, or (not
                that good, but still acceptable) do an AllocVec(0x7FFFFFF0).

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node AllocVec "exec.library / AllocVec"
@Nav "AllocVec"
@Parent exec

@{B} e x e c . l i b r a r y @{UB}                                       @{B} AllocVec @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          allocating 0 bytes

@{B}SEVERITY@{UB}        Level 1

@{B}EXPLANATION@{UB}     Allocating 0 bytes is ugly, wastes time and might also
                fail. Avoid this if possible.

@{B}DEADLY@{UB}          has no effect.

__________________________________________________________________________


@{B}REPORT@{UB}          don't use AllocVec(-1) to flush memory

@{B}SEVERITY@{UB}        Level 1

@{B}EXPLANATION@{UB}     To flush the memory, you should either call AvailMem(),
                then add some byte to the result and allocate this, or (not
                that good, but still acceptable) do an AllocVec(0x7FFFFFF0).

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node CopyMem "exec.library / CopyMem"
@Nav "CopyMem"
@Parent exec

@{B} e x e c . l i b r a r y @{UB}                                        @{B} CopyMem @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          memory areas are overlapping (incremental)

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     Copying overlapping memory areas are not supported. See
                AutoDocs! This is a incremental copy (destination before
                source).

@{B}DEADLY@{UB}          has no effect.

@{B}REMARK@{UB}          I got a lot of request to remove this hit, or at least
                set it to Level 1 or so because it works fine. This is
                against the philosophy of PatchWork. To cite the AutoDocs:

                 "@{B}Arbitrary overlapping copies are not supported.@{UB}"

                I think this is plain speak. We have to obey this, if we
                like it or not, and if it may currently work or not.

                I will remove this hit as soon as the AutoDocs says that it
                is all right to do so. No further discussion.

__________________________________________________________________________


@{B}REPORT@{UB}          memory areas are overlapping (decremental)

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     Copying overlapping memory areas is not supported. See
                AutoDocs! This is a decremental copy (source before
                destination), which will even fail on AmigaOS up to 3.1!

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node CopyMemQuick "exec.library / CopyMemQuick"
@Nav "CopyMemQuick"
@Parent exec

@{B} e x e c . l i b r a r y @{UB}                                   @{B} CopyMemQuick @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          pointer/size not longword aligned

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     This is a raw violation, and will most probably cause
                a crash! In this case, you MUST use CopyMem() instead.

@{B}DEADLY@{UB}          has no effect.

__________________________________________________________________________


@{B}REPORT@{UB}          memory areas are overlapping (incremental)

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     Copying overlapping memory areas are not supported. See
                AutoDocs! This is a incremental copy (destination before
                source).

@{B}DEADLY@{UB}          has no effect.

@{B}REMARK@{UB}          I got a lot of request to remove this hit, or at least
                set it to Level 1 or so because it works fine. This is
                against the philosophy of PatchWork. To cite the AutoDocs:

                 "@{B}Arbitrary overlapping copies are not supported.@{UB}"

                I think this is plain speak. We have to obey this, if we
                like it or not, and if it may currently work or not.

                I will remove this hit as soon as the AutoDocs says that it
                is all right to do so. No further discussion.

__________________________________________________________________________


@{B}REPORT@{UB}          memory areas are overlapping (decremental)

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     Copying overlapping memory areas is not supported. See
                AutoDocs! This is a decremental copy (source before
                destination), which will even fail on AmigaOS up to 3.1!

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node CreateIORequest "exec.library / CreateIORequest"
@Nav "CreateIORequest"
@Parent exec

@{B} e x e c . l i b r a r y @{UB}                                @{B} CreateIORequest @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          size is too small

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     There is something wrong with your code. Size cannot
                be smaller than the size of a minimal IORequest struc-
                ture. This will most probably cause MuForce hits and
                Mungwall hits.

@{B}DEADLY@{UB}          has no effect.

__________________________________________________________________________


@{B}REPORT@{UB}          ioReplyPort not initialized

@{B}SEVERITY@{UB}        Level 2

@{B}EXPLANATION@{UB}     CreateIORequest requires an initialized structure. See
                AutoDocs!

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node DeleteMsgPort "exec.library / DeleteMsgPort"
@Nav "DeleteMsgPort"
@Parent exec

@{B} e x e c . l i b r a r y @{UB}                                  @{B} DeleteMsgPort @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          MsgPort contained unreplied Messages

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     You must reply all messages you have in your MsgPort
                before deleting it. Otherwise it will cause memory loss
                and some programs might wait for the reply forever. Also
                see AutoDocs!

@{B}DEADLY@{UB}          has no effect.

__________________________________________________________________________


@{B}REPORT@{UB}          MsgPort is still public

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     First call RemPort() before deleting the port!

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node Enable "exec.library / Enable"
@Nav "Enable"
@Parent exec

@{B} e x e c . l i b r a r y @{UB}                                         @{B} Enable @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          Disable() missing

@{B}SEVERITY@{UB}        Level 2

@{B}EXPLANATION@{UB}     There was an Enable() call though interrupts are already
                enabled. Do not use Disable() to neutralize a following
                Enable().

@{B}DEADLY@{UB}          has no effect.

__________________________________________________________________________


@{B}REPORT@{UB}          Disable time exceeded (1234 ms)

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     Only if DISABLECHECK has been enabled!

                Autodocs allow to disable interrupts for a maximum of
                250ms. This time has been exceeded. Try to split up the
                code in the disabled section, so interrupts are enabled
                in appropriate time slices. It would be even better if
                you find a solution to avoid disabling the interrupts
                at all.

                This test requires at least an 68020, and will not work
                properly on Amiga emulations.

                It may also occur if the disabled section threw other
                hits.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node FindPort "exec.library / FindPort"
@Nav "FindPort"
@Parent exec

@{B} e x e c . l i b r a r y @{UB}                                       @{B} FindPort @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          Forbid() missing, unreliable result

@{B}SEVERITY@{UB}        Level 2

@{B}EXPLANATION@{UB}     This is one of the hits that occures most. You MUST
                freeze multitasking before searching through the public
                list for a message port. Otherwise the port could be
                shut up shortly after you've got the pointer. The next
                PutMsg() will then throw MuForce hits in best case, or
                it will just trash memory. Also see AutoDocs!

@{B}DEADLY@{UB}          In DEADLY mode, this function call will return the
                true return code only if multitasking was forbidden.
                Otherwise it will pass NULL if the Port wasn't there
                anyhow, or 0xFACEDEAD if the Port was found. So, just
                finding out if this port existed will still work, but
                accessing it will cause MuForce hits.

@{B}REMARK@{UB}          Some people claim that this hit is annoying, since they
                consider this practice to be legal if you only want to
                find out if a port is available or not.

                I don't think so. There is still a slight chance to
                crash the system. Imagine your program is iterating the
                list without Forbid(), looking for a certain Node B
                which comes after Node A. Now, while FindPort() is
                fetching Node A, a scheduling occurs and another process
                gets the processor. This other process now removes Node A
                from the list and changes its memory contents. If your
                program then gets the processor back, it will get a
                completely messed up 'Node A', and will crash.

                It is sad, but as long as AmigaOS does not provide a
                semaphore mechanism for public lists, we must use Forbid()
                if we iterate through them.

@EndNode
@Node FindSemaphore "exec.library / FindSemaphore"
@Nav "FindSemaphore"
@Parent exec

@{B} e x e c . l i b r a r y @{UB}                                  @{B} FindSemaphore @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          Forbid() missing, unreliable result

@{B}SEVERITY@{UB}        Level 2

@{B}EXPLANATION@{UB}     You MUST freeze multitasking before searching a
                public Semaphore. Otherwise the semaphore could be
                removed shortly after you've got the pointer. An access
                to the structure will then throw MuForce hits in best
                case, or it will just trash memory. Also see AutoDocs!

@{B}DEADLY@{UB}          In DEADLY mode, this function call will return the
                true return code only if multitasking was forbidden.
                Otherwise it will pass NULL if the Semaphore wasn't
                there anyhow, or 0xFACEDEAD if the Semaphore was found.
                So, just finding out if this semaphore existed will still
                work, but accessing it will cause MuForce hits.

@{B}REMARK@{UB}          Some people claim that this hit is annoying, since they
                consider this practice to be legal if you only want to
                find out if a port is available or not.

                I don't think so. There is still a slight chance to
                crash the system. Imagine your program is iterating the
                list without Forbid(), looking for a certain Node B
                which comes after Node A. Now, while FindPort() is
                fetching Node A, a scheduling occurs and another process
                gets the processor. This other process now removes Node A
                from the list and changes its memory contents. If your
                program then gets the processor back, it will get a
                completely messed up 'Node A', and will crash.

                It is sad, but as long as AmigaOS does not provide a
                semaphore mechanism for public lists, we must use Forbid()
                if we iterate through them.

@EndNode
@Node FindTask "exec.library / FindTask"
@Nav "FindTask"
@Parent exec

@{B} e x e c . l i b r a r y @{UB}                                       @{B} FindTask @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          Forbid() missing, unreliable result

@{B}SEVERITY@{UB}        Level 2

@{B}EXPLANATION@{UB}     If you search for a task by its name, you MUST freeze
                multitasking before searching through the public task
                list. Otherwise the task could be removed shortly after
                you've got the pointer. Any access to the TCB will then
                throw MuForce hits in best case, or it will just trash
               memory.

                Anyhow, FindTask(NULL) will work fine even with enabled
                multitasking. This is because there is no iterating
                through the public lists of tasks required to find the
                own task, and if you can use the result, you'll surely
                be still alive... ;-)

@{B}DEADLY@{UB}          In DEADLY mode, this function call will return the
                true return code only if multitasking was forbidden
                or NULL has been passed as task name. Otherwise it will
                return NULL if the task really wasn't there, or
                0xFACEDEAD if the task was found. So, just finding out
                if this task existed will still work, but accessing it
                will cause MuForce hits.

@{B}REMARK@{UB}          Some people claim that this hit is annoying, since they
                consider this practice to be legal if you only want to
                find out if a port is available or not.

                I don't think so. There is still a slight chance to
                crash the system. Imagine your program is iterating the
                list without Forbid(), looking for a certain Node B
                which comes after Node A. Now, while FindPort() is
                fetching Node A, a scheduling occurs and another process
                gets the processor. This other process now removes Node A
                from the list and changes its memory contents. If your
                program then gets the processor back, it will get a
                completely messed up 'Node A', and will crash.

                It is sad, but as long as AmigaOS does not provide a
                semaphore mechanism for public lists, we must use Forbid()
                if we iterate through them.

@EndNode
@Node FreeSignal "exec.library / FreeSignal"
@Nav "FreeSignal"
@Parent exec

@{B} e x e c . l i b r a r y @{UB}                                     @{B} FreeSignal @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          V37+ will be required

@{B}SEVERITY@{UB}        Level 0, MinOS 37

@{B}EXPLANATION@{UB}     Just a rememberance that you'll need at least AmigaOS
                V37 to call FreeSignal(-1).

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node InitSemaphore "exec.library / InitSemaphore"
@Nav "InitSemaphore"
@Parent exec

@{B} e x e c . l i b r a r y @{UB}                                  @{B} InitSemaphore @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          structure is not cleared

@{B}SEVERITY@{UB}        Level 2

@{B}EXPLANATION@{UB}     The memory space passed to be initialized as a new
                semaphore must be cleared according to the AutoDocs.
                Even if it seemingly works fine without clearing up the
                memory mess, you must do it! No further discussion.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node OldOpenLibrary "exec.library / OldOpenLibrary"
@Nav "OldOpenLibrary"
@Parent exec

@{B} e x e c . l i b r a r y @{UB}                                 @{B} OldOpenLibrary @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          obsoleted, use OpenLibrary() instead

@{B}SEVERITY@{UB}        Level 1

@{B}EXPLANATION@{UB}     Not much to say. Just follow the advice! But please
                do NOT just replace it by a lazy OpenLibrary(...,0).
                This isn't much better...

@{B}DEADLY@{UB}          has no effect. Yet...

@{B}REMARK@{UB}          I've got a lot of response on this one. All of them have
                two arguments in common that people gave against this hit.

                The first one is that the AutoDocs do not explicitely say
                not to use this function. Anyhow, this is implied by: "This
                @{U}obsolete@{UU} function is provided so that object code compiled
                using a 1.0 system will still run." To say it in another
                words: this call is only to be used in software that is
                ought to run under Kick 1.0. Obsolete functions must not be
                used in new code!

                The second argument is that you can save 2 (in words: two)
                byte by using this function instead of OpenLibrary(). This
                is ridiculous, IMHO. First of all, let your program have
                10 Open calls (which is rather much), you'd save 20 byte.
                This is no price for future compatibility. Another problem
                is the missing library version checking.

@EndNode
@Node Permit "exec.library / Permit"
@Nav "Permit"
@Parent exec

@{B} e x e c . l i b r a r y @{UB}                                         @{B} Permit @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          Forbid() missing

@{B}SEVERITY@{UB}        Level 2

@{B}EXPLANATION@{UB}     There was a Permit() call though multitasking is already
                active. Do not use Permit() to neutralize a following
                Forbid().

@{B}DEADLY@{UB}          has no effect.

@{B}REMARK@{UB}          This check will not be performed with the NOPERMIT
                option set.

@EndNode
@Node Procure "exec.library / Procure"
@Nav "Procure"
@Parent exec

@{B} e x e c . l i b r a r y @{UB}                                        @{B} Procure @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          V39+ will be required

@{B}SEVERITY@{UB}        Level 0, MinOS 39

@{B}EXPLANATION@{UB}     Procure() is only working in V39 or higher. Don't use
                it on older AmigaOS releases!

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node ReleaseSemaphore "exec.library / ReleaseSemaphore"
@Nav "ReleaseSemaphore"
@Parent exec

@{B} e x e c . l i b r a r y @{UB}                               @{B} ReleaseSemaphore @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          semaphore is not obtained

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     The semaphore has already been released. You must
                release any semaphore exactly as often as you obtained
                it.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node ReleaseSemaphoreList "exec.library / ReleaseSemaphoreList"
@Nav "ReleaseSemaphoreList"
@Parent exec

@{B} e x e c . l i b r a r y @{UB}                           @{B} ReleaseSemaphoreList @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          semaphore @0x4321ABDC is not obtained

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     The semaphore has already been released. You must
                release any semaphore exactly as often as you obtained
                it.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node SetFunction "exec.library / SetFunction"
@Nav "SetFunction"
@Parent exec

@{B} e x e c . l i b r a r y @{UB}                                    @{B} SetFunction @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          The function offset must be negative

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     You must provide a negative function offset!

@{B}DEADLY@{UB}          has no effect.

__________________________________________________________________________


@{B}REPORT@{UB}          Requested function does not exist

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     The library does not have a function with that offset. If
                you want to patch functions which are only available in
                later OS versions, you must make sure that you have the
                right version number before applying the patch!

@{B}DEADLY@{UB}          has no effect.

__________________________________________________________________________


@{B}REPORT@{UB}          Your patch is called before SetFunction() returns

@{B}SEVERITY@{UB}        Level 2

@{B}EXPLANATION@{UB}     This is a lack of the AutoDocs, so be careful. If you use
                the SetFunction()'s result to build a chain, you must not
                patch CacheClearU() and SumLibrary() since SetFunction()
                will call these function after writing the new vector, but
                before returning to the client!

                If there is no extra Forbid()/Disable(), you also must not
                patch Supervisor() and Schedule()! (Like all private functions,
                you shouldn't patch Schedule() anyhow!)

@{B}DEADLY@{UB}          has no effect.

__________________________________________________________________________


@{B}REPORT@{UB}          Forbid() missing

@{B}SEVERITY@{UB}        Level 2

@{B}EXPLANATION@{UB}     You should generally forbid the task scheduling when you
                are about to patch the system. There is a slight probab-
                ility that your patched function is called by another task
                while you are still building up the chain.

                If you are patching functions which can be called by
                interrupts, make sure to also Disable() the system for
                the time that your patch is not completed.

                BTW: don't forget to clear the instruction cache when you
                have finished the chaining.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node Vacate "exec.library / Vacate"
@Nav "Vacate"
@Parent exec

@{B} e x e c . l i b r a r y @{UB}                                         @{B} Vacate @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          V39+ will be required

@{B}SEVERITY@{UB}        Level 0

@{B}EXPLANATION@{UB}     Vacate() is only working in V39 or higher. Don't use
                it on older AmigaOS releases!

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node gadtools "gadtools.library"
@Topic "Checks"

@{B} g a d t o o l s . l i b r a r y @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

   These gadtools.library patches are implemented:

                @{" CreateContext " link CreateContext}
                @{" CreateGadgetA " link CreateGadgetA}
                @{" GT_GetGadgetAttrsA " link GT_GetGadgetAttrsA}
                @{" GT_RefreshWindow " link GT_RefreshWindow}
                @{" GT_SetGadgetAttrsA " link GT_SetGadgetAttrsA}

@EndNode
@Node CreateContext "gadtools.library / CreateContext"
@Nav "CreateContext"
@Parent gadtools

@{B} g a d t o o l s . l i b r a r y @{UB}                          @{B} CreateContext @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          glistpointer is not set to NULL

@{B}SEVERITY@{UB}        Level 2

@{B}EXPLANATION@{UB}     The glistpointer you pass in must be initialized to NULL.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node CreateGadgetA "gadtools.library / CreateGadgetA"
@Nav "CreateGadgetA"
@Parent gadtools

@{B} g a d t o o l s . l i b r a r y @{UB}                          @{B} CreateGadgetA @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          illegal gadget kind 19

@{B}SEVERITY@{UB}        Level 2

@{B}EXPLANATION@{UB}     The gadget kind you've passed in, is unknown to GadTools

@{B}DEADLY@{UB}          has no effect.

__________________________________________________________________________


@{B}REPORT@{UB}          previous must not be NULL

@{B}SEVERITY@{UB}        Level 2

@{B}EXPLANATION@{UB}     You have to set the previous parameter!

@{B}DEADLY@{UB}          has no effect.

__________________________________________________________________________


@{B}REPORT@{UB}          newgad must not be NULL

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     You have not passed in a NewGadget structure. This hit
                will most probably also cause MuForce hits.

@{B}DEADLY@{UB}          has no effect.

__________________________________________________________________________


@{B}REPORT@{UB}          no ng_VisualInfo given

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     You must pass a valid VisualInfo in your NewGadget
                structure. This hit will most probably also cause
                MuForce hits.

@{B}DEADLY@{UB}          has no effect.

__________________________________________________________________________


@{B}REPORT@{UB}          no ng_TextAttr given

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     You must pass a valid TextAttr in your NewGadget
                structure. This hit will most probably also cause
                MuForce hits.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node GT_GetGadgetAttrsA "gadtools.library / GT_GetGadgetAttrsA"
@Nav "GT_GetGadgetAttrsA"
@Parent gadtools

@{B} g a d t o o l s . l i b r a r y @{UB}                     @{B} GT_GetGadgetAttrsA @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          set req to NULL for future compatibility

@{B}SEVERITY@{UB}        Level 2

@{B}EXPLANATION@{UB}     speaks for itself.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node GT_RefreshWindow "gadtools.library / GT_RefreshWindow"
@Nav "GT_RefreshWindow"
@Parent gadtools

@{B} g a d t o o l s . l i b r a r y @{UB}                       @{B} GT_RefreshWindow @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          set req to NULL for future compatibility

@{B}SEVERITY@{UB}        Level 2

@{B}EXPLANATION@{UB}     speaks for itself.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node GT_SetGadgetAttrsA "gadtools.library / GT_SetGadgetAttrsA"
@Nav "GT_SetGadgetAttrsA"
@Parent gadtools

@{B} g a d t o o l s . l i b r a r y @{UB}                     @{B} GT_SetGadgetAttrsA @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          set req to NULL for future compatibility

@{B}SEVERITY@{UB}        Level 2

@{B}EXPLANATION@{UB}     speaks for itself.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node graphics "graphics.library"
@Topic "Checks"

@{B} g r a p h i c s . l i b r a r y @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

   These graphics.library patches are implemented:

                @{" AllocSpriteDataA " link AllocSpriteDataA}
                @{" AreaEllipse " link AreaEllipse}  also AreaCircle()
                @{" BestModeIDA " link BestModeIDA}
                @{" BitMapScale " link BitMapScale}
                @{" ChangeSprite " link ChangeSprite}
                @{" ChangeVPBitMap " link ChangeVPBitMap}
                @{" DrawEllipse " link DrawEllipse}  also DrawCircle()
                @{" EraseRect " link EraseRect}
                @{" FreeColorMap " link FreeColorMap}
                @{" GetExtSpriteA " link GetExtSpriteA}
                @{" MakeVPort " link MakeVPort}
                @{" RectFill " link RectFill}
                @{" ScalerDiv " link ScalerDiv}
                @{" SetChipRev " link SetChipRev}
                @{" SetFont " link SetFont}
                @{" SetMaxPen " link SetMaxPen}
                @{" WaitBOVP " link WaitBOVP}
                @{" WriteChunkyPixels " link WriteChunkyPixels}

@EndNode
@Node AllocSpriteDataA "graphics.library / AllocSpriteDataA"
@Nav "AllocSpriteDataA"
@Parent graphics

@{B} g r a p h i c s . l i b r a r y @{UB}                       @{B} AllocSpriteDataA @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          bitmap (h=10) isn't tall enough for sprite (h=16)

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     See AutoDocs! You can see the height of the BitMap and
                the height of the sprite.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node AreaEllipse "graphics.library / AreaEllipse"
@Nav "AreaEllipse"
@Parent graphics

@{B} g r a p h i c s . l i b r a r y @{UB}                            @{B} AreaEllipse @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          ellipse radius must be > 0

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     Speaks for itself. Also see AutoDocs!

@{B}DEADLY@{UB}          has no effect.

@{B}REMEMBER@{UB}        that AreaCircle() is only a macro calling AreaEllipse()!

@EndNode
@Node BestModeIDA "graphics.library / BestModeIDA"
@Nav "BestModeIDA"
@Parent graphics

@{B} g r a p h i c s . l i b r a r y @{UB}                            @{B} BestModeIDA @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          Tag BIDTAG_NominalWidth: 0 is not allowed
                Tag BIDTAG_NominalHeight: 0 is not allowed
                Tag BIDTAG_DesiredWidth: 0 is not allowed
                Tag BIDTAG_DesiredHeight: 0 is not allowed

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     Will most probably cause a division by zero.

@{B}DEADLY@{UB}          has no effect.

__________________________________________________________________________


@{B}REPORT@{UB}          Tag BIDTAG_NominalWidth: out of UWORD range
                Tag BIDTAG_NominalHeight: out of UWORD range
                Tag BIDTAG_DesiredWidth: out of UWORD range
                Tag BIDTAG_DesiredHeight: out of UWORD range

@{B}SEVERITY@{UB}        Level 1

@{B}EXPLANATION@{UB}     These tags require an UWORD. The upper word will
                most probably be ignored.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node BitMapScale "graphics.library / BitMapScale"
@Nav "BitMapScale"
@Parent graphics

@{B} g r a p h i c s . l i b r a r y @{UB}                            @{B} BitMapScale @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          bsa_XSrcFactor (=16395) must be within 1..16383
                bsa_XDestFactor (=0) must be within 1..16383
                bsa_YSrcFactor (=16777) must be within 1..16383
                bsa_YDestFactor (=0) must be within 1..16383

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     No further comment required.

@{B}DEADLY@{UB}          has no effect.

__________________________________________________________________________


@{B}REPORT@{UB}          bsa_Flags is not 0

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     Don't ask, just do it!

@{B}DEADLY@{UB}          has no effect.

__________________________________________________________________________


@{B}REPORT@{UB}          Bug: cannot copy with width > 1024 (see autodocs)

@{B}SEVERITY@{UB}        Level 2

@{B}EXPLANATION@{UB}     BitMapScale is only capable to use the old Agnus'
                blitter, so width is limited to 1024, if XSrcFactor
                equals XDestFactor. You must accept this even if it
                works fine under your graphics board emulation.

@{B}DEADLY@{UB}          has no effect.

__________________________________________________________________________


@{B}REPORT@{UB}          Bug: cannot expand in Y direction (see autodocs)

@{B}SEVERITY@{UB}        Level 2

@{B}EXPLANATION@{UB}     The Y range has been exceeded. See AutoDocs for
                their calculation.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node ChangeSprite "graphics.library / ChangeSprite"
@Nav "ChangeSprite"
@Parent graphics

@{B} g r a p h i c s . l i b r a r y @{UB}                           @{B} ChangeSprite @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          spriteimage not initialized

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     You must initialize the spriteimage structure as
                described in the autodocs. Otherwise your sprite might
                be messed up.

                As only exception, this test is skipped if the sprite
                has a height of 0 (i.e. it is hidden).

@{B}DEADLY@{UB}          has no effect.

__________________________________________________________________________


@{B}REPORT@{UB}          spriteimage must be in CHIP RAM

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     ...since Amiga custom chips need it there. ;-)

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node ChangeVPBitMap "graphics.library / ChangeVPBitMap"
@Nav "ChangeVPBitMap"
@Parent graphics

@{B} g r a p h i c s . l i b r a r y @{UB}                         @{B} ChangeVPBitMap @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          Current bitmap @0x12345678 and new bitmap @0x3456789A do not match

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     For double buffering, both bitmaps must match in
                dimension, arrangement and depth. For better debugging,
                you get a pointer to the currently displayed BitMap and
                the BitMap structure that will replace it.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node DrawEllipse "graphics.library / DrawEllipse"
@Nav "DrawEllipse"
@Parent graphics

@{B} g r a p h i c s . l i b r a r y @{UB}                            @{B} DrawEllipse @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          ellipse radius must be > 0

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     Speaks for itself. Also see AutoDocs!

@{B}DEADLY@{UB}          has no effect.

@{B}REMEMBER@{UB}        that DrawCircle() is only a macro calling DrawEllipse()!

@EndNode
@Node EraseRect "graphics.library / EraseRect"
@Nav "EraseRect"
@Parent graphics

@{B} g r a p h i c s . l i b r a r y @{UB}                              @{B} EraseRect @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          max must be >= min

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     xmax/ymax must not be lower than xmin/ymin!

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node FreeColorMap "graphics.library / FreeColorMap"
@Nav "FreeColorMap"
@Parent graphics

@{B} g r a p h i c s . l i b r a r y @{UB}                           @{B} FreeColorMap @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          V39+ will be required

@{B}SEVERITY@{UB}        Level 0, MinOS 39

@{B}EXPLANATION@{UB}     if you pass a NULL pointer!

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node GetExtSpriteA "graphics.library / GetExtSpriteA"
@Nav "GetExtSpriteA"
@Parent graphics

@{B} g r a p h i c s . l i b r a r y @{UB}                          @{B} GetExtSpriteA @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          V40+ will be required for proper operation

@{B}SEVERITY@{UB}        Level 0, MinOS 40

@{B}EXPLANATION@{UB}     This function is very buggy until V40.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node MakeVPort "graphics.library / MakeVPort"
@Nav "MakeVPort"
@Parent graphics

@{B} g r a p h i c s . l i b r a r y @{UB}                              @{B} MakeVPort @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          ViewPort->RasInfo has not been set

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     RasInfo must be valid!

@{B}DEADLY@{UB}          has no effect.

__________________________________________________________________________


@{B}REPORT@{UB}          DUALPF ViewPort->RasInfo.Next has not been set

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     You must pass a second RasInfo if you use the Dual
                Playfield mode.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node RectFill "graphics.library / RectFill"
@Nav "RectFill"
@Parent graphics

@{B} g r a p h i c s . l i b r a r y @{UB}                               @{B} RectFill @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          max must be >= min

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     xmax/ymax must not be lower than xmin/ymin!

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node ScalerDiv "graphics.library / ScalerDiv"
@Nav "ScalerDiv"
@Parent graphics

@{B} g r a p h i c s . l i b r a r y @{UB}                              @{B} ScalerDiv @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          parameters are out of range

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     see AutoDocs.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node SetChipRev "graphics.library / SetChipRev"
@Nav "SetChipRev"
@Parent graphics

@{B} g r a p h i c s . l i b r a r y @{UB}                             @{B} SetChipRev @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          don't use this function!

@{B}SEVERITY@{UB}        Level 1

@{B}EXPLANATION@{UB}     Must be called only once. SetPatch does it for you.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node SetFont "graphics.library / SetFont"
@Nav "SetFont"
@Parent graphics

@{B} g r a p h i c s . l i b r a r y @{UB}                                @{B} SetFont @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          NULL fonts are not allowed

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     Since V36, NULL fonts are not allowed any more. They
                will produce MuForce hits!

@{B}DEADLY@{UB}          has no effect.

__________________________________________________________________________


@{B}REPORT@{UB}          BTW: foobar.font/8 variant is obsoleted in V36+

@{B}SEVERITY@{UB}        Level 0

@{B}EXPLANATION@{UB}     Just a reminder that this font does not meet the V36
                requirements any more. SetFont will convert it for proper
                use, but you shouldn't use this font any more.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node SetMaxPen "graphics.library / SetMaxPen"
@Nav "SetMaxPen"
@Parent graphics

@{B} g r a p h i c s . l i b r a r y @{UB}                              @{B} SetMaxPen @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          maxpen==0 doesn't make much sense

@{B}SEVERITY@{UB}        Level 1

@{B}EXPLANATION@{UB}     No further comment.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node WaitBOVP "graphics.library / WaitBOVP"
@Nav "WaitBOVP"
@Parent graphics

@{B} g r a p h i c s . l i b r a r y @{UB}                               @{B} WaitBOVP @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          busy wait, don't use if ever possible

@{B}SEVERITY@{UB}        Level 1

@{B}EXPLANATION@{UB}     In fact, this function busy waits until the desired
                raster line has been reached. If you can avoid this
                function, then you should do it by all means!

@{B}DEADLY@{UB}          has no effect.

@{B}REMARK@{UB}          This check has been temporarily disactivated, since
                CyberGraphX is doing a clean emulation without busy loop.

@EndNode
@Node WriteChunkyPixels "graphics.library / WriteChunkyPixels"
@Nav "WriteChunkyPixels"
@Parent graphics

@{B} g r a p h i c s . l i b r a r y @{UB}                      @{B} WriteChunkyPixels @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          stop must be >= start

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     xstop/ystop must not be lower than xstart/ystart!

@{B}DEADLY@{UB}          has no effect.

__________________________________________________________________________


@{B}REPORT@{UB}          no chunky-to-planar hardware, this will be slow

@{B}SEVERITY@{UB}        Level 0

@{B}EXPLANATION@{UB}     There was no chunky-to-planar hardware found in
                your system, so the CPU will have to do all the heavy
                lifting. If you have a better way for this operation, you
                should use that one instead.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node intuition "intuition.library"
@Topic "Checks"

@{B} i n t u i t i o n . l i b r a r y @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

   These intuition.library patches are implemented:

                @{" CloseWindow " link CloseWindow}
                @{" EasyRequestArgs " link EasyRequestArgs}
                @{" GadgetMouse " link GadgetMouse}
                @{" GetDefaultPubScreen " link GetDefaultPubScreen}
                @{" MakeClass " link MakeClass}
                @{" MakeScreen " link MakeScreen}
                @{" ModifyIDCMP " link ModifyIDCMP}
                @{" RemakeDisplay " link RemakeDisplay}
                @{" Request " link Request}
                @{" RethinkDisplay " link RethinkDisplay}
                @{" ScreenDepth " link ScreenDepth}
                @{" SetEditHook " link SetEditHook}
                @{" SetMenuStrip " link SetMenuStrip}
                @{" SetPointer " link SetPointer}

@EndNode
@Node CloseWindow "intuition.library / CloseWindow"
@Nav "CloseWindow"
@Parent intuition

@{B} i n t u i t i o n . l i b r a r y @{UB}                          @{B} CloseWindow @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          still 4 Messages in the shared Window queue

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     These are two very serious mistakes in one. If you
                use a shared Window MessagePort, you MUST reply all
                pending messages, then clear the UserPort pointer and
                set the IDCMP flags to 0. See the intuition AutoDocs
                for a good example of how to safely close a shared
                window.

                It is most likely that this hit is followed by several
                MuForce and Mungwall hits.

@{B}DEADLY@{UB}          has no effect.

__________________________________________________________________________


@{B}REPORT@{UB}          MenuStrip @0x4567ABAC not cleared

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     You must clear the menu strip before closing the
                window.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node EasyRequestArgs "intuition.library / EasyRequestArgs"
@Nav "EasyRequestArgs"
@Parent intuition

@{B} i n t u i t i o n . l i b r a r y @{UB}                      @{B} EasyRequestArgs @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          no gadget specified

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     You must at least specify one gadget!

@{B}DEADLY@{UB}          has no effect.

__________________________________________________________________________


@{B}REPORT@{UB}          es_StructSize is wrong (12 byte)

@{B}SEVERITY@{UB}        Level 2

@{B}EXPLANATION@{UB}     The es_StructSize field must be properly initialized.
                Set the size of the EasyStruct.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node GadgetMouse "intuition.library / GadgetMouse"
@Nav "GadgetMouse"
@Parent intuition

@{B} i n t u i t i o n . l i b r a r y @{UB}                          @{B} GadgetMouse @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          obsoleted, improve your class implementation

@{B}SEVERITY@{UB}        Level 1

@{B}EXPLANATION@{UB}     This function is obsoleted, since the hook routines get
                the mouse pointer position directly. It is recommended
                not to call this function!

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node GetDefaultPubScreen "intuition.library / GetDefaultPubScreen"
@Nav "GetDefaultPubScreen"
@Parent intuition

@{B} i n t u i t i o n . l i b r a r y @{UB}                  @{B} GetDefaultPubScreen @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          -

@{B}SEVERITY@{UB}        None, DEADLY mode only

@{B}EXPLANATION@{UB}     None

@{B}DEADLY@{UB}          This function usually returns a pointer to the public
                screen, but you must not use this pointer for reading
                the screen's structure! In DEADLY mode, NULL is returned
                when GetDefaultPubScreen() returned NULL itself. Otherwise
                0xFACEDEAD is returned, so you will get an MuForce hit
                when you try to read the screen structure.

@EndNode
@Node MakeClass "intuition.library / MakeClass"
@Nav "MakeClass"
@Parent intuition

@{B} i n t u i t i o n . l i b r a r y @{UB}                            @{B} MakeClass @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          no superclass specified

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     You must specify the superclass of your class.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node MakeScreen "intuition.library / MakeScreen"
@Nav "MakeScreen"
@Parent intuition

@{B} i n t u i t i o n . l i b r a r y @{UB}                           @{B} MakeScreen @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          return code requires V39+

@{B}SEVERITY@{UB}        Level 0

@{B}EXPLANATION@{UB}     See autodocs.

@{B}DEADLY@{UB}          Always returns FALSE (non-zero).

@EndNode
@Node ModifyIDCMP "intuition.library / ModifyIDCMP"
@Nav "ModifyIDCMP"
@Parent intuition

@{B} i n t u i t i o n . l i b r a r y @{UB}                          @{B} ModifyIDCMP @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          still 4 Messages in the shared Window queue

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     This is very serious. You MUST reply all pending messages
                of the window BEFORE setting the IDCMP flags to 0.

                It is most likely that this hit is followed by several
                MuForce and Mungwall hits.

                Also see @{" CloseWindow " link CloseWindow}.

@{B}DEADLY@{UB}          has no effect.

__________________________________________________________________________


@{B}REPORT@{UB}          return code requires V37+

@{B}SEVERITY@{UB}        Level 0

@{B}EXPLANATION@{UB}     See autodocs.

@{B}DEADLY@{UB}          has no effect, to guarantee an useable system.

@EndNode
@Node RemakeDisplay "intuition.library / RemakeDisplay"
@Nav "RemakeDisplay"
@Parent intuition

@{B} i n t u i t i o n . l i b r a r y @{UB}                        @{B} RemakeDisplay @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          return code requires V39+

@{B}SEVERITY@{UB}        Level 0

@{B}EXPLANATION@{UB}     See autodocs.

@{B}DEADLY@{UB}          Always returns FALSE (non-zero).

@EndNode
@Node Request "intuition.library / Request"
@Nav "Request"
@Parent intuition

@{B} i n t u i t i o n . l i b r a r y @{UB}                              @{B} Request @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          maximum of 8 requesters exceeded

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     Due to a bug in intuition, there is a maximum of 8 requesters
                that are supported in a window and can be changed in
                size, position, or depth.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node RethinkDisplay "intuition.library / RethinkDisplay"
@Nav "RethinkDisplay"
@Parent intuition

@{B} i n t u i t i o n . l i b r a r y @{UB}                       @{B} RethinkDisplay @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          return code requires V39+

@{B}SEVERITY@{UB}        Level 0

@{B}EXPLANATION@{UB}     See autodocs.

@{B}DEADLY@{UB}          Always returns FALSE (non-zero).

@EndNode
@Node ScreenDepth "intuition.library / ScreenDepth"
@Nav "ScreenDepth"
@Parent intuition

@{B} i n t u i t i o n . l i b r a r y @{UB}                          @{B} ScreenDepth @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          reserved must be NULL

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     The parameter in A1 is reserved and must be set to NULL
                for future compatibility!

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node SetEditHook "intuition.library / SetEditHook"
@Nav "SetEditHook"
@Parent intuition

@{B} i n t u i t i o n . l i b r a r y @{UB}                          @{B} SetEditHook @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          risky function

@{B}SEVERITY@{UB}        Level 0

@{B}EXPLANATION@{UB}     See autodocs.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node SetMenuStrip "intuition.library / SetMenuStrip"
@Nav "SetMenuStrip"
@Parent intuition

@{B} i n t u i t i o n . l i b r a r y @{UB}                         @{B} SetMenuStrip @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          where is the menu?

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     You provided a NULL pointer as menu.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node SetPointer "intuition.library / SetPointer"
@Nav "SetPointer"
@Parent intuition

@{B} i n t u i t i o n . l i b r a r y @{UB}                           @{B} SetPointer @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          sprite data must be in CHIP ram

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     to be reachable by the custom chips. DraCo user
                can ignore this hit.

@{B}DEADLY@{UB}          has no effect.

__________________________________________________________________________

@{B}REPORT@{UB}          width must be below 16

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     The hardware is limited to a width of 16 pixel.

@{B}DEADLY@{UB}          has no effect.

__________________________________________________________________________


@{B}REPORT@{UB}          hot spot is outside of the sprite

@{B}SEVERITY@{UB}        Level 0

@{B}EXPLANATION@{UB}     The provided offset defines a hot spot that lies outside
                of the sprite borders and could irritate the user.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node utility "utility.library"
@Topic "Checks"

@{B} u t i l i t y . l i b r a r y @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

   These utility.library patches are implemented:

                @{" AllocNamedObjectA " link AllocNamedObjectA}
                @{" MapTags " link MapTags}
                @{" SDivMod32 " link SDivMod32}
                @{" UDivMod32 " link UDivMod32}

@EndNode
@Node AllocNamedObjectA "utility.library / AllocNamedObjectA"
@Nav "AllocNamedObjectA"
@Parent utility

@{B} u t i l i t y . l i b r a r y @{UB}                        @{B} AllocNamedObjectA @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          no object name specified

@{B}SEVERITY@{UB}        Level 3

@{B}EXPLANATION@{UB}     You must provide a string pointer in A0

@{B}DEADLY@{UB}          has no effect.

__________________________________________________________________________


@{B}REPORT@{UB}          bad ANO_Flags=0x12345678

@{B}SEVERITY@{UB}        Level 1

@{B}EXPLANATION@{UB}     You must only use NSF_NODUPS or NSF_CASE. All other bits
                are reserved for future purposes.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node MapTags "utility.library / MapTags"
@Nav "MapTags"
@Parent utility

@{B} u t i l i t y . l i b r a r y @{UB}                                  @{B} MapTags @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          V39+ required for this mapType

@{B}SEVERITY@{UB}        Level 0

@{B}EXPLANATION@{UB}     Only MAP_KEEP_NOT_FOUND is functional until V39.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node SDivMod32 "utility.library / SDivMod32"
@Nav "SDivMod32"
@Parent utility

@{B} u t i l i t y . l i b r a r y @{UB}                                @{B} SDivMod32 @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          division by zero

@{B}SEVERITY@{UB}        Level 0

@{B}EXPLANATION@{UB}     See elementary school.

@{B}DEADLY@{UB}          has no effect.

@EndNode
@Node UDivMod32 "utility.library / UDivMod32"
@Nav "UDivMod32"
@Parent utility

@{B} u t i l i t y . l i b r a r y @{UB}                                @{B} UDivMod32 @{UB}
__________________________________________________________________________
@{FG SHINE}¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{FG TEXT}

@{B}REPORT@{UB}          division by zero

@{B}SEVERITY@{UB}        Level 0

@{B}EXPLANATION@{UB}     See elementary school.

@{B}DEADLY@{UB}          has no effect.

@EndNode
